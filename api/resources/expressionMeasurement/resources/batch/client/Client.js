/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __awaiter =
    (this && this.__awaiter) ||
    function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import * as serializers from "../../../../../../serialization/index";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../../../errors/index";
import { toJson } from "../../../../../../core/json";
export class Batch {
    constructor(_options = {}) {
        this._options = _options;
    }
    /**
     * Sort and filter jobs.
     *
     * @param {Hume.expressionMeasurement.batch.BatchListJobsRequest} request
     * @param {Batch.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.listJobs()
     */
    listJobs(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__listJobs(request, requestOptions));
    }
    __listJobs() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c, _d;
            const { limit, status, when, timestampMs, sortBy, direction } = request;
            const _queryParams = {};
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (status != null) {
                if (Array.isArray(status)) {
                    _queryParams["status"] = status.map((item) =>
                        serializers.expressionMeasurement.batch.Status.jsonOrThrow(item, {
                            unrecognizedObjectKeys: "strip",
                        }),
                    );
                } else {
                    _queryParams["status"] = serializers.expressionMeasurement.batch.Status.jsonOrThrow(status, {
                        unrecognizedObjectKeys: "strip",
                    });
                }
            }
            if (when != null) {
                _queryParams["when"] = serializers.expressionMeasurement.batch.When.jsonOrThrow(when, {
                    unrecognizedObjectKeys: "strip",
                });
            }
            if (timestampMs != null) {
                _queryParams["timestamp_ms"] = timestampMs.toString();
            }
            if (sortBy != null) {
                _queryParams["sort_by"] = serializers.expressionMeasurement.batch.SortBy.jsonOrThrow(sortBy, {
                    unrecognizedObjectKeys: "strip",
                });
            }
            if (direction != null) {
                _queryParams["direction"] = serializers.expressionMeasurement.batch.Direction.jsonOrThrow(direction, {
                    unrecognizedObjectKeys: "strip",
                });
            }
            const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
                url: urlJoin(
                    (_c =
                        (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0
                            ? _b
                            : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0
                        ? _c
                        : environments.HumeEnvironment.Production,
                    "v0/batch/jobs",
                ),
                method: "GET",
                headers: mergeHeaders(
                    (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers,
                    mergeOnlyDefinedHeaders(Object.assign({}, yield this._getCustomAuthorizationHeaders())),
                    requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers,
                ),
                queryParameters: _queryParams,
                timeoutMs:
                    (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !=
                    null
                        ? requestOptions.timeoutInSeconds * 1000
                        : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return {
                    data: serializers.expressionMeasurement.batch.listJobs.Response.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                    rawResponse: _response.rawResponse,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.HumeTimeoutError("Timeout exceeded when calling GET /v0/batch/jobs.");
                case "unknown":
                    throw new errors.HumeError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Start a new measurement inference job.
     *
     * @param {Hume.expressionMeasurement.batch.InferenceBaseRequest} request
     * @param {Batch.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.startInferenceJob({
     *         urls: ["https://hume-tutorials.s3.amazonaws.com/faces.zip"],
     *         notify: true
     *     })
     */
    startInferenceJob(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__startInferenceJob(request, requestOptions));
    }
    __startInferenceJob(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
                url: urlJoin(
                    (_c =
                        (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0
                            ? _b
                            : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0
                        ? _c
                        : environments.HumeEnvironment.Production,
                    "v0/batch/jobs",
                ),
                method: "POST",
                headers: mergeHeaders(
                    (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers,
                    mergeOnlyDefinedHeaders(Object.assign({}, yield this._getCustomAuthorizationHeaders())),
                    requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers,
                ),
                contentType: "application/json",
                requestType: "json",
                body: serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request, {
                    unrecognizedObjectKeys: "strip",
                }),
                timeoutMs:
                    (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !=
                    null
                        ? requestOptions.timeoutInSeconds * 1000
                        : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return {
                    data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                    rawResponse: _response.rawResponse,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.HumeTimeoutError("Timeout exceeded when calling POST /v0/batch/jobs.");
                case "unknown":
                    throw new errors.HumeError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get the request details and state of a given job.
     *
     * @param {string} id - The unique identifier for the job.
     * @param {Batch.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.getJobDetails("job_id")
     */
    getJobDetails(id, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getJobDetails(id, requestOptions));
    }
    __getJobDetails(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
                url: urlJoin(
                    (_c =
                        (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0
                            ? _b
                            : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0
                        ? _c
                        : environments.HumeEnvironment.Production,
                    `v0/batch/jobs/${encodeURIComponent(id)}`,
                ),
                method: "GET",
                headers: mergeHeaders(
                    (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers,
                    mergeOnlyDefinedHeaders(Object.assign({}, yield this._getCustomAuthorizationHeaders())),
                    requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers,
                ),
                timeoutMs:
                    (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !=
                    null
                        ? requestOptions.timeoutInSeconds * 1000
                        : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return {
                    data: serializers.expressionMeasurement.batch.UnionJob.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                    rawResponse: _response.rawResponse,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.HumeTimeoutError("Timeout exceeded when calling GET /v0/batch/jobs/{id}.");
                case "unknown":
                    throw new errors.HumeError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get the JSON predictions of a completed inference job.
     *
     * @param {string} id - The unique identifier for the job.
     * @param {Batch.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.getJobPredictions("job_id")
     */
    getJobPredictions(id, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getJobPredictions(id, requestOptions));
    }
    __getJobPredictions(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
                url: urlJoin(
                    (_c =
                        (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0
                            ? _b
                            : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0
                        ? _c
                        : environments.HumeEnvironment.Production,
                    `v0/batch/jobs/${encodeURIComponent(id)}/predictions`,
                ),
                method: "GET",
                headers: mergeHeaders(
                    (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers,
                    mergeOnlyDefinedHeaders(Object.assign({}, yield this._getCustomAuthorizationHeaders())),
                    requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers,
                ),
                timeoutMs:
                    (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !=
                    null
                        ? requestOptions.timeoutInSeconds * 1000
                        : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return {
                    data: serializers.expressionMeasurement.batch.getJobPredictions.Response.parseOrThrow(
                        _response.body,
                        {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        },
                    ),
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                    rawResponse: _response.rawResponse,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.HumeTimeoutError(
                        "Timeout exceeded when calling GET /v0/batch/jobs/{id}/predictions.",
                    );
                case "unknown":
                    throw new errors.HumeError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get the artifacts ZIP of a completed inference job.
     */
    getJobArtifacts(id, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getJobArtifacts(id, requestOptions));
    }
    __getJobArtifacts(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
                url: urlJoin(
                    (_c =
                        (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0
                            ? _b
                            : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0
                        ? _c
                        : environments.HumeEnvironment.Production,
                    `v0/batch/jobs/${encodeURIComponent(id)}/artifacts`,
                ),
                method: "GET",
                headers: mergeHeaders(
                    (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers,
                    mergeOnlyDefinedHeaders(Object.assign({}, yield this._getCustomAuthorizationHeaders())),
                    requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers,
                ),
                responseType: "streaming",
                timeoutMs:
                    (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !=
                    null
                        ? requestOptions.timeoutInSeconds * 1000
                        : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                    rawResponse: _response.rawResponse,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.HumeTimeoutError(
                        "Timeout exceeded when calling GET /v0/batch/jobs/{id}/artifacts.",
                    );
                case "unknown":
                    throw new errors.HumeError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Start a new batch inference job.
     *
     * @param {core.FileLike[]} file
     * @param {Hume.expressionMeasurement.batch.BatchStartInferenceJobFromLocalFileRequest} request
     * @param {Batch.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expressionMeasurement.batch.startInferenceJobFromLocalFile([fs.createReadStream("/path/to/your/file")], {})
     */
    startInferenceJobFromLocalFile(file, request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(
            this.__startInferenceJobFromLocalFile(file, request, requestOptions),
        );
    }
    __startInferenceJobFromLocalFile(file, request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const _request = yield core.newFormData();
            if (request.json != null) {
                _request.append(
                    "json",
                    toJson(
                        serializers.expressionMeasurement.batch.InferenceBaseRequest.jsonOrThrow(request.json, {
                            unrecognizedObjectKeys: "strip",
                        }),
                    ),
                );
            }
            for (const _file of file) {
                yield _request.appendFile("file", _file);
            }
            const _maybeEncodedRequest = yield _request.getRequest();
            const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
                url: urlJoin(
                    (_c =
                        (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0
                            ? _b
                            : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0
                        ? _c
                        : environments.HumeEnvironment.Production,
                    "v0/batch/jobs",
                ),
                method: "POST",
                headers: mergeHeaders(
                    (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers,
                    mergeOnlyDefinedHeaders(
                        Object.assign(
                            Object.assign({}, yield this._getCustomAuthorizationHeaders()),
                            _maybeEncodedRequest.headers,
                        ),
                    ),
                    requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers,
                ),
                requestType: "file",
                duplex: _maybeEncodedRequest.duplex,
                body: _maybeEncodedRequest.body,
                timeoutMs:
                    (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !=
                    null
                        ? requestOptions.timeoutInSeconds * 1000
                        : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return {
                    data: serializers.expressionMeasurement.batch.JobId.parseOrThrow(_response.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        breadcrumbsPrefix: ["response"],
                    }),
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                    rawResponse: _response.rawResponse,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.HumeTimeoutError("Timeout exceeded when calling POST /v0/batch/jobs.");
                case "unknown":
                    throw new errors.HumeError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter(this, void 0, void 0, function* () {
            const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
            return { "X-Hume-Api-Key": apiKeyValue };
        });
    }
}
