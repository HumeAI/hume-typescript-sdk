diff --git a/src/auth/HeaderAuthProvider.ts b/src/auth/HeaderAuthProvider.ts
index 8089bcc..83c2e42 100644
--- a/src/auth/HeaderAuthProvider.ts
+++ b/src/auth/HeaderAuthProvider.ts
@@ -1,24 +1,10 @@
-/**
- * THIS FILE IS MANUALLY MAINTAINED: see .fernignore
- *
- * Custom HeaderAuthProvider that supports both apiKey and accessToken authentication.
- * When accessToken is provided to HumeClient, the wrapper converts it to an
- * Authorization: Bearer header. This provider checks for both apiKey and the
- * Authorization header to support both auth methods.
- */
+// This file was auto-generated by Fern from our API Definition.
 
 import * as core from "../core/index.js";
 import * as errors from "../errors/index.js";
 
-export namespace HeaderAuthProvider {
-    export type AuthOptions = {
-        apiKey?: core.Supplier<string | undefined>;
-    };
-
-    export type Options = {
-        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
-    } & AuthOptions;
-}
+const PARAM_KEY = "apiKey" as const;
+const HEADER_NAME = "X-Hume-Api-Key" as const;
 
 export class HeaderAuthProvider implements core.AuthProvider {
     private readonly options: HeaderAuthProvider.Options;
@@ -27,37 +13,36 @@ export class HeaderAuthProvider implements core.AuthProvider {
         this.options = options;
     }
 
-    public static canCreate(options: HeaderAuthProvider.Options): boolean {
-        return options.apiKey != null || HeaderAuthProvider.hasAuthorizationHeader(options.headers);
-    }
-
-    private static hasAuthorizationHeader(
-        headers: Record<string, string | core.Supplier<string | null | undefined> | null | undefined> | undefined,
-    ): boolean {
-        if (!headers) return false;
-        return Object.keys(headers).some((key) => key.toLowerCase() === "authorization");
+    public static canCreate(options: Partial<HeaderAuthProvider.Options>): boolean {
+        return options?.[PARAM_KEY] != null;
     }
 
-    public async getAuthRequest(_arg?: { endpointMetadata?: core.EndpointMetadata }): Promise<core.AuthRequest> {
-        // Check apiKey first (preferred method)
-        const apiKey = await core.Supplier.get(this.options.apiKey);
-        if (apiKey != null) {
-            return { headers: { "X-Hume-Api-Key": apiKey } };
+    public async getAuthRequest({
+        endpointMetadata,
+    }: {
+        endpointMetadata?: core.EndpointMetadata;
+    } = {}): Promise<core.AuthRequest> {
+        const headerValue = await core.Supplier.get(this.options[PARAM_KEY]);
+        if (headerValue == null) {
+            throw new errors.HumeError({
+                message: HeaderAuthProvider.AUTH_CONFIG_ERROR_MESSAGE,
+            });
         }
 
-        // Check for Authorization header (from accessToken)
-        if (this.options.headers) {
-            const authKey = Object.keys(this.options.headers).find((key) => key.toLowerCase() === "authorization");
-            if (authKey) {
-                const authValue = await core.Supplier.get(this.options.headers[authKey]);
-                if (authValue != null) {
-                    return { headers: { Authorization: authValue } };
-                }
-            }
-        }
+        return {
+            headers: { [HEADER_NAME]: headerValue },
+        };
+    }
+}
 
-        throw new errors.HumeError({
-            message: "Please provide either 'apiKey' or 'accessToken' when initializing the client",
-        });
+export namespace HeaderAuthProvider {
+    export const AUTH_SCHEME = "HeaderAuthScheme" as const;
+    export const AUTH_CONFIG_ERROR_MESSAGE: string =
+        `Please provide '${PARAM_KEY}' when initializing the client` as const;
+    export type Options = AuthOptions;
+    export type AuthOptions = { [PARAM_KEY]: core.Supplier<string> };
+
+    export function createInstance(options: Options): core.AuthProvider {
+        return new HeaderAuthProvider(options);
     }
 }
