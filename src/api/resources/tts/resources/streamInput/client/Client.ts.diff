diff --git a/src/api/resources/tts/resources/streamInput/client/Client.ts b/src/api/resources/tts/resources/streamInput/client/Client.ts
index e8477c1..4e3ef08 100644
--- a/src/api/resources/tts/resources/streamInput/client/Client.ts
+++ b/src/api/resources/tts/resources/streamInput/client/Client.ts
@@ -2,7 +2,6 @@
 
 import type { BaseClientOptions } from "../../../../../../BaseClient.js";
 import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
-import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
 import * as core from "../../../../../../core/index.js";
 import * as environments from "../../../../../../environments.js";
 import * as serializers from "../../../../../../serialization/index.js";
@@ -10,7 +9,7 @@ import type * as Hume from "../../../../../index.js";
 import { StreamInputSocket } from "./Socket.js";
 
 export declare namespace StreamInputClient {
-    export interface Options extends BaseClientOptions {}
+    export type Options = BaseClientOptions;
 
     export interface ConnectArgs {
         accessToken?: string;
@@ -53,70 +52,42 @@ export class StreamInputClient {
             debug,
             reconnectAttempts,
         } = args;
-        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
-        if (accessToken != null) {
-            _queryParams.access_token = accessToken;
-        }
-
-        if (contextGenerationId != null) {
-            _queryParams.context_generation_id = contextGenerationId;
-        }
-
-        if (formatType != null) {
-            _queryParams.format_type = serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
-                unrecognizedObjectKeys: "strip",
-                omitUndefined: true,
-            });
-        }
-
-        if (includeTimestampTypes != null) {
-            if (Array.isArray(includeTimestampTypes)) {
-                _queryParams.include_timestamp_types = includeTimestampTypes.map((item) =>
-                    serializers.tts.TimestampType.jsonOrThrow(item, {
+        const _queryParams: Record<string, unknown> = {
+            access_token: accessToken,
+            context_generation_id: contextGenerationId,
+            format_type:
+                formatType != null
+                    ? serializers.tts.AudioFormatType.jsonOrThrow(formatType, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      })
+                    : undefined,
+            include_timestamp_types: Array.isArray(includeTimestampTypes)
+                ? includeTimestampTypes.map((item) =>
+                      serializers.tts.TimestampType.jsonOrThrow(item, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      }),
+                  )
+                : includeTimestampTypes != null
+                  ? serializers.tts.TimestampType.jsonOrThrow(includeTimestampTypes, {
                         unrecognizedObjectKeys: "strip",
                         omitUndefined: true,
-                    }),
-                );
-            } else {
-                _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
-                    includeTimestampTypes,
-                    {
-                        unrecognizedObjectKeys: "strip",
-                        omitUndefined: true,
-                    },
-                );
-            }
-        }
-
-        if (instantMode != null) {
-            _queryParams.instant_mode = instantMode.toString();
-        }
-
-        if (noBinary != null) {
-            _queryParams.no_binary = noBinary.toString();
-        }
-
-        if (stripHeaders != null) {
-            _queryParams.strip_headers = stripHeaders.toString();
-        }
-
-        if (version != null) {
-            _queryParams.version = serializers.tts.OctaveVersion.jsonOrThrow(version, {
-                unrecognizedObjectKeys: "strip",
-                omitUndefined: true,
-            });
-        }
-
-        if (apiKey != null) {
-            _queryParams.api_key = apiKey;
-        }
-
-        const _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({
-                ...(await this._getCustomAuthorizationHeaders()),
-            }),
-            headers,
-        );
+                    })
+                  : undefined,
+            instant_mode: instantMode,
+            no_binary: noBinary,
+            strip_headers: stripHeaders,
+            version:
+                version != null
+                    ? serializers.tts.OctaveVersion.jsonOrThrow(version, {
+                          unrecognizedObjectKeys: "strip",
+                          omitUndefined: true,
+                      })
+                    : undefined,
+            api_key: apiKey,
+        };
+        const _headers: Record<string, unknown> = { ...headers };
         const socket = new core.ReconnectingWebSocket({
             url: core.url.join(
                 (await core.Supplier.get(this._options.baseUrl)) ??
@@ -130,13 +101,4 @@ export class StreamInputClient {
         });
         return new StreamInputSocket({ socket });
     }
-
-    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
-    }
 }
