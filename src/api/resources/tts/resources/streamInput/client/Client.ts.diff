diff --git a/src/api/resources/tts/resources/streamInput/client/Client.ts b/src/api/resources/tts/resources/streamInput/client/Client.ts
index e8477c1..3870133 100644
--- a/src/api/resources/tts/resources/streamInput/client/Client.ts
+++ b/src/api/resources/tts/resources/streamInput/client/Client.ts
@@ -1,7 +1,6 @@
 // This file was auto-generated by Fern from our API Definition.
 
 import type { BaseClientOptions } from "../../../../../../BaseClient.js";
-import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../../../BaseClient.js";
 import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
 import * as core from "../../../../../../core/index.js";
 import * as environments from "../../../../../../environments.js";
@@ -9,19 +8,19 @@ import * as serializers from "../../../../../../serialization/index.js";
 import type * as Hume from "../../../../../index.js";
 import { StreamInputSocket } from "./Socket.js";
 
-export declare namespace StreamInputClient {
+export declare namespace StreamInput {
     export interface Options extends BaseClientOptions {}
 
     export interface ConnectArgs {
-        accessToken?: string;
-        contextGenerationId?: string;
-        formatType?: Hume.tts.AudioFormatType;
-        includeTimestampTypes?: Hume.tts.TimestampType | Hume.tts.TimestampType[];
-        instantMode?: boolean;
-        noBinary?: boolean;
-        stripHeaders?: boolean;
-        version?: Hume.tts.OctaveVersion;
-        apiKey?: string;
+        accessToken?: string | undefined;
+        contextGenerationId?: string | undefined;
+        formatType?: Hume.tts.AudioFormatType | undefined;
+        includeTimestampTypes?: Hume.tts.TimestampType | undefined;
+        instantMode?: boolean | undefined;
+        noBinary?: boolean | undefined;
+        stripHeaders?: boolean | undefined;
+        version?: Hume.tts.OctaveVersion | undefined;
+        apiKey?: string | undefined;
         /** Arbitrary headers to send with the websocket connect request. */
         headers?: Record<string, string>;
         /** Enable debug mode on the websocket. Defaults to false. */
@@ -31,14 +30,14 @@ export declare namespace StreamInputClient {
     }
 }
 
-export class StreamInputClient {
-    protected readonly _options: NormalizedClientOptions<StreamInputClient.Options>;
+export class StreamInput {
+    protected readonly _options: StreamInput.Options;
 
-    constructor(options: StreamInputClient.Options = {}) {
-        this._options = normalizeClientOptions(options);
+    constructor(_options: StreamInput.Options = {}) {
+        this._options = _options;
     }
 
-    public async connect(args: StreamInputClient.ConnectArgs = {}): Promise<StreamInputSocket> {
+    public async connect(args: StreamInput.ConnectArgs = {}): Promise<StreamInputSocket> {
         const {
             accessToken,
             contextGenerationId,
@@ -80,10 +79,7 @@ export class StreamInputClient {
             } else {
                 _queryParams.include_timestamp_types = serializers.tts.TimestampType.jsonOrThrow(
                     includeTimestampTypes,
-                    {
-                        unrecognizedObjectKeys: "strip",
-                        omitUndefined: true,
-                    },
+                    { unrecognizedObjectKeys: "strip", omitUndefined: true },
                 );
             }
         }
@@ -112,9 +108,7 @@ export class StreamInputClient {
         }
 
         const _headers: Record<string, unknown> = mergeHeaders(
-            mergeOnlyDefinedHeaders({
-                ...(await this._getCustomAuthorizationHeaders()),
-            }),
+            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
             headers,
         );
         const socket = new core.ReconnectingWebSocket({
@@ -131,12 +125,8 @@ export class StreamInputClient {
         return new StreamInputSocket({ socket });
     }
 
-    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | null | undefined>> {
-        const apiKeyValue = core.Supplier.get(this._options.apiKey);
-        // This `authHeaderValue` is manually added as if you don't provide it it will
-        // be omitted from the headers which means it won't reach the logic in ws.ts that
-        // extracts values from the headers and adds them to query parameters.
-        const authHeaderValue = core.Supplier.get(this._options.headers?.authorization);
-        return { "X-Hume-Api-Key": apiKeyValue, Authorization: authHeaderValue };
+    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
+        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
+        return { "X-Hume-Api-Key": apiKeyValue };
     }
 }
