// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as core from "../../../../../../core/index.js";
import * as environments from "../../../../../../environments.js";
import * as errors from "../../../../../../errors/index.js";
import * as serializers from "../../../../../../serialization/index.js";
import * as Hume from "../../../../../index.js";

export declare namespace Prompts {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Prompts {
    protected readonly _options: Prompts.Options;

    constructor(_options: Prompts.Options = {}) {
        this._options = _options;
    }

    /**
     * Fetches a paginated list of **Prompts**.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.ListPromptsPromptsRequest} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.listPrompts({
     *         pageNumber: 0,
     *         pageSize: 2
     *     })
     */
    public async listPrompts(
        request: Hume.empathicVoice.ListPromptsPromptsRequest = {},
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.Page<Hume.empathicVoice.ReturnPrompt | null, Hume.empathicVoice.ReturnPagedPrompts>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Hume.empathicVoice.ListPromptsPromptsRequest,
            ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> => {
                const { pageNumber, pageSize, restrictToMostRecent, name } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                if (pageNumber != null) {
                    _queryParams.page_number = pageNumber.toString();
                }
                if (pageSize != null) {
                    _queryParams.page_size = pageSize.toString();
                }
                if (restrictToMostRecent != null) {
                    _queryParams.restrict_to_most_recent = restrictToMostRecent.toString();
                }
                if (name != null) {
                    _queryParams.name = name;
                }
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    this._options?.headers,
                    mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod)
                                .base,
                        "v0/evi/prompts",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Hume.empathicVoice.BadRequestError(
                                serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                                    unrecognizedObjectKeys: "passthrough",
                                    allowUnrecognizedUnionMembers: true,
                                    allowUnrecognizedEnumValues: true,
                                    skipValidation: true,
                                    breadcrumbsPrefix: ["response"],
                                }),
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.HumeError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.HumeError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.HumeTimeoutError("Timeout exceeded when calling GET /v0/evi/prompts.");
                    case "unknown":
                        throw new errors.HumeError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            },
        );
        let _offset = request?.pageNumber != null ? request?.pageNumber : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Hume.empathicVoice.ReturnPrompt | null, Hume.empathicVoice.ReturnPagedPrompts>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.promptsPage ?? []).length > 0,
            getItems: (response) => response?.promptsPage ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "pageNumber", _offset));
            },
        });
    }

    /**
     * Creates a **Prompt** that can be added to an [EVI configuration](/reference/speech-to-speech-evi/configs/create-config).
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.PostedPrompt} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.createPrompt({
     *         name: "Weather Assistant Prompt",
     *         text: "<role>You are an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>"
     *     })
     */
    public createPrompt(
        request: Hume.empathicVoice.PostedPrompt,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | null> {
        return core.HttpResponsePromise.fromPromise(this.__createPrompt(request, requestOptions));
    }

    private async __createPrompt(
        request: Hume.empathicVoice.PostedPrompt,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | null>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                "v0/evi/prompts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPrompt.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.createPrompt.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError("Timeout exceeded when calling POST /v0/evi/prompts.");
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Fetches a list of a **Prompt's** versions.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.ListPromptVersionsPromptsRequest} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.listPromptVersions({
     *         id: "af699d45-2985-42cc-91b9-af9e5da3bac5"
     *     })
     */
    public listPromptVersions(
        request: Hume.empathicVoice.ListPromptVersionsPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPagedPrompts> {
        return core.HttpResponsePromise.fromPromise(this.__listPromptVersions(request, requestOptions));
    }

    private async __listPromptVersions(
        request: Hume.empathicVoice.ListPromptVersionsPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPagedPrompts>> {
        const { id, pageNumber, pageSize, restrictToMostRecent } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (pageNumber != null) {
            _queryParams.page_number = pageNumber.toString();
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        if (restrictToMostRecent != null) {
            _queryParams.restrict_to_most_recent = restrictToMostRecent.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.ReturnPagedPrompts.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError("Timeout exceeded when calling GET /v0/evi/prompts/{id}.");
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates a **Prompt** by creating a new version of the **Prompt**.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.PostedPromptVersion} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.createPromptVersion({
     *         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *         text: "<role>You are an updated version of an AI weather assistant providing users with accurate and up-to-date weather information. Respond to user queries concisely and clearly. Use simple language and avoid technical jargon. Provide temperature, precipitation, wind conditions, and any weather alerts. Include helpful tips if severe weather is expected.</role>",
     *         versionDescription: "This is an updated version of the Weather Assistant Prompt."
     *     })
     */
    public createPromptVersion(
        request: Hume.empathicVoice.PostedPromptVersion,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | null> {
        return core.HttpResponsePromise.fromPromise(this.__createPromptVersion(request, requestOptions));
    }

    private async __createPromptVersion(
        request: Hume.empathicVoice.PostedPromptVersion,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | null>> {
        const { id, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptVersion.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.createPromptVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError("Timeout exceeded when calling POST /v0/evi/prompts/{id}.");
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a **Prompt** and its versions.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.DeletePromptPromptsRequest} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.deletePrompt({
     *         id: "af699d45-2985-42cc-91b9-af9e5da3bac5"
     *     })
     */
    public deletePrompt(
        request: Hume.empathicVoice.DeletePromptPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deletePrompt(request, requestOptions));
    }

    private async __deletePrompt(
        request: Hume.empathicVoice.DeletePromptPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { id } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError("Timeout exceeded when calling DELETE /v0/evi/prompts/{id}.");
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates the name of a **Prompt**.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.PostedPromptName} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.updatePromptName({
     *         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *         name: "Updated Weather Assistant Prompt Name"
     *     })
     */
    public updatePromptName(
        request: Hume.empathicVoice.PostedPromptName,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__updatePromptName(request, requestOptions));
    }

    private async __updatePromptName(
        request: Hume.empathicVoice.PostedPromptName,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const { id, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptName.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "text",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError("Timeout exceeded when calling PATCH /v0/evi/prompts/{id}.");
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Fetches a specified version of a **Prompt**.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.GetPromptVersionPromptsRequest} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.getPromptVersion({
     *         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *         version: 0
     *     })
     */
    public getPromptVersion(
        request: Hume.empathicVoice.GetPromptVersionPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | null> {
        return core.HttpResponsePromise.fromPromise(this.__getPromptVersion(request, requestOptions));
    }

    private async __getPromptVersion(
        request: Hume.empathicVoice.GetPromptVersionPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | null>> {
        const { id, version } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.getPromptVersion.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError(
                    "Timeout exceeded when calling GET /v0/evi/prompts/{id}/version/{version}.",
                );
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a specified version of a **Prompt**.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.DeletePromptVersionPromptsRequest} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.deletePromptVersion({
     *         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *         version: 1
     *     })
     */
    public deletePromptVersion(
        request: Hume.empathicVoice.DeletePromptVersionPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deletePromptVersion(request, requestOptions));
    }

    private async __deletePromptVersion(
        request: Hume.empathicVoice.DeletePromptVersionPromptsRequest,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { id, version } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError(
                    "Timeout exceeded when calling DELETE /v0/evi/prompts/{id}/version/{version}.",
                );
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates the description of a **Prompt**.
     *
     * See our [prompting guide](/docs/speech-to-speech-evi/guides/phone-calling) for tips on crafting your system prompt.
     *
     * @param {Hume.empathicVoice.PostedPromptVersionDescription} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Hume.empathicVoice.BadRequestError}
     *
     * @example
     *     await client.empathicVoice.prompts.updatePromptDescription({
     *         id: "af699d45-2985-42cc-91b9-af9e5da3bac5",
     *         version: 1,
     *         versionDescription: "This is an updated version_description."
     *     })
     */
    public updatePromptDescription(
        request: Hume.empathicVoice.PostedPromptVersionDescription,
        requestOptions?: Prompts.RequestOptions,
    ): core.HttpResponsePromise<Hume.empathicVoice.ReturnPrompt | null> {
        return core.HttpResponsePromise.fromPromise(this.__updatePromptDescription(request, requestOptions));
    }

    private async __updatePromptDescription(
        request: Hume.empathicVoice.PostedPromptVersionDescription,
        requestOptions?: Prompts.RequestOptions,
    ): Promise<core.WithRawResponse<Hume.empathicVoice.ReturnPrompt | null>> {
        const { id, version, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.HumeEnvironment.Prod).base,
                `v0/evi/prompts/${core.url.encodePathParam(id)}/version/${core.url.encodePathParam(version)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.empathicVoice.PostedPromptVersionDescription.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.empathicVoice.prompts.updatePromptDescription.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Hume.empathicVoice.BadRequestError(
                        serializers.empathicVoice.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.HumeError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.HumeTimeoutError(
                    "Timeout exceeded when calling PATCH /v0/evi/prompts/{id}/version/{version}.",
                );
            case "unknown":
                throw new errors.HumeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "X-Hume-Api-Key": apiKeyValue };
    }
}
